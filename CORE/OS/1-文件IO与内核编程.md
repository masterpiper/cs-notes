```toc
```

## 文件描述符、标准I/O与流

## 用户模式和内核模式

### 进程上下文和中断上下文
内核中在执行的程序只有一下两种上下文
- 进程上下文：进程运行时寄存器内容和堆栈信息等。
- 中断上下文：执行中断处理程序时寄存器内容和堆栈信息等。
#### 关于中断上下文
*中断不属于任何进程。* 中断程序运行时必然会占有CPU资源，一般不可被打断。
**因为中断并不存在调度一说，所以一旦中断处于睡眠或者放弃CPu的使用将直接导致死机。在中断竞争临界资源时只能等待临界资源被释放才可继续执行中断下文**。


## linux内核编程

### argc与argv

### 进程通信
#### pipe
pipe(int fd[2]):实现了将两个进程的通信，其中fd[2]分别为两个进程中的文件描述符，由于pipe为半双工所以fd[]中至少有一个文件描述为输出流或者输入流。
```c

int fd[2];
char buf[1];
pipe(fd);
// we set 0-read 1-write

if(fork()==0){//child write
close(fd[0]);
fprint(fd[1],"a");
}
else{//parents read
close(fd[1]);
read(fd[0],buf,sizeof(buf));
fprint(1,"%c\n",buf[0]);
}
//now child write and parents read.
```
pipe()的建立在fork()之前，因此fork后，父子进程都有pipe相同的pipe描述符（*我们把pipe看作一种特殊的文件，因此可以通过文件描述符来对它进行操作，由于pipe写入或读出时另一种操作会被阻塞，因此pipe实现了进程间的同步通信，从而每次读出都会清空pipe*），因此为了实现单向的通信，父子进程要协商好那个fd的那个描述符作为输入和输出，然后在该进程中关闭相应的描述符。

#### 自旋锁


#### 临时文件
全双工的进程通信方式。